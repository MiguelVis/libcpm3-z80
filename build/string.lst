                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.1.6 #12391 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module string
                                      6 	.optsdcc -mz80
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _memchr
                                     12 	.globl _memcmp
                                     13 	.globl _memcpy
                                     14 	.globl _memset
                                     15 	.globl _strlen
                                     16 	.globl _strcpy
                                     17 	.globl _strncpy
                                     18 	.globl _strcmp
                                     19 	.globl _strncmp
                                     20 	.globl _strchr
                                     21 	.globl _strrchr
                                     22 	.globl _strsep
                                     23 	.globl _strcspn
                                     24 	.globl _strtok
                                     25 	.globl _strerror
                                     26 ;--------------------------------------------------------
                                     27 ; special function registers
                                     28 ;--------------------------------------------------------
                                     29 ;--------------------------------------------------------
                                     30 ; ram data
                                     31 ;--------------------------------------------------------
                                     32 	.area _DATA
                           000000    33 Lstring.strtok$last$1_0$74==.
      000000                         34 _strtok_last_65536_74:
      000000                         35 	.ds 2
                                     36 ;--------------------------------------------------------
                                     37 ; ram data
                                     38 ;--------------------------------------------------------
                                     39 	.area _INITIALIZED
                                     40 ;--------------------------------------------------------
                                     41 ; absolute external ram data
                                     42 ;--------------------------------------------------------
                                     43 	.area _DABS (ABS)
                                     44 ;--------------------------------------------------------
                                     45 ; global & static initialisations
                                     46 ;--------------------------------------------------------
                                     47 	.area _HOME
                                     48 	.area _GSINIT
                                     49 	.area _GSFINAL
                                     50 	.area _GSINIT
                                     51 ;--------------------------------------------------------
                                     52 ; Home
                                     53 ;--------------------------------------------------------
                                     54 	.area _HOME
                                     55 	.area _HOME
                                     56 ;--------------------------------------------------------
                                     57 ; code
                                     58 ;--------------------------------------------------------
                                     59 	.area _CODE
                           000000    60 	G$memchr$0$0	= .
                                     61 	.globl	G$memchr$0$0
                           000000    62 	C$string.c$20$0_0$21	= .
                                     63 	.globl	C$string.c$20$0_0$21
                                     64 ;string.c:20: void *memchr(const void *s, int c, size_t n) {
                                     65 ;	---------------------------------
                                     66 ; Function memchr
                                     67 ; ---------------------------------
      000000                         68 _memchr::
      000000 DD E5            [15]   69 	push	ix
      000002 DD 21 00 00      [14]   70 	ld	ix,#0
      000006 DD 39            [15]   71 	add	ix,sp
      000008 F5               [11]   72 	push	af
                           000009    73 	C$string.c$21$2_0$21	= .
                                     74 	.globl	C$string.c$21$2_0$21
                                     75 ;string.c:21: const unsigned char *s_ = s;
      000009 DD 7E 04         [19]   76 	ld	a, 4 (ix)
      00000C DD 77 FE         [19]   77 	ld	-2 (ix), a
      00000F DD 7E 05         [19]   78 	ld	a, 5 (ix)
      000012 DD 77 FF         [19]   79 	ld	-1 (ix), a
                           000015    80 	C$string.c$22$1_0$21	= .
                                     81 	.globl	C$string.c$22$1_0$21
                                     82 ;string.c:22: const unsigned char c_ = (unsigned char)c;
      000015 DD 4E 06         [19]   83 	ld	c, 6 (ix)
                           000018    84 	C$string.c$24$1_0$21	= .
                                     85 	.globl	C$string.c$24$1_0$21
                                     86 ;string.c:24: for (size_t i = 0; i < n; ++i) {
      000018 11 00 00         [10]   87 	ld	de, #0x0000
      00001B                         88 00105$:
      00001B 7B               [ 4]   89 	ld	a, e
      00001C DD 96 08         [19]   90 	sub	a, 8 (ix)
      00001F 7A               [ 4]   91 	ld	a, d
      000020 DD 9E 09         [19]   92 	sbc	a, 9 (ix)
      000023 30 0D            [12]   93 	jr	NC, 00103$
                           000025    94 	C$string.c$25$3_0$23	= .
                                     95 	.globl	C$string.c$25$3_0$23
                                     96 ;string.c:25: if (s_[i] == c_) {
      000025 E1               [10]   97 	pop	hl
      000026 E5               [11]   98 	push	hl
      000027 19               [11]   99 	add	hl, de
      000028 46               [ 7]  100 	ld	b, (hl)
      000029 79               [ 4]  101 	ld	a, c
      00002A 90               [ 4]  102 	sub	a, b
      00002B 28 08            [12]  103 	jr	Z, 00107$
                           00002D   104 	C$string.c$26$4_0$24	= .
                                    105 	.globl	C$string.c$26$4_0$24
                                    106 ;string.c:26: return (void *)(s_ + i);
      00002D 18 00            [12]  107 	jr	00106$
      00002F                        108 00106$:
                           00002F   109 	C$string.c$24$2_0$22	= .
                                    110 	.globl	C$string.c$24$2_0$22
                                    111 ;string.c:24: for (size_t i = 0; i < n; ++i) {
      00002F 13               [ 6]  112 	inc	de
      000030 18 E9            [12]  113 	jr	00105$
      000032                        114 00103$:
                           000032   115 	C$string.c$30$1_0$21	= .
                                    116 	.globl	C$string.c$30$1_0$21
                                    117 ;string.c:30: return NULL;
      000032 21 00 00         [10]  118 	ld	hl, #0x0000
      000035                        119 00107$:
                           000035   120 	C$string.c$31$1_0$21	= .
                                    121 	.globl	C$string.c$31$1_0$21
                                    122 ;string.c:31: }
      000035 DD F9            [10]  123 	ld	sp, ix
      000037 DD E1            [14]  124 	pop	ix
                           000039   125 	C$string.c$31$1_0$21	= .
                                    126 	.globl	C$string.c$31$1_0$21
                           000039   127 	XG$memchr$0$0	= .
                                    128 	.globl	XG$memchr$0$0
      000039 C9               [10]  129 	ret
                           00003A   130 	G$memcmp$0$0	= .
                                    131 	.globl	G$memcmp$0$0
                           00003A   132 	C$string.c$33$1_0$26	= .
                                    133 	.globl	C$string.c$33$1_0$26
                                    134 ;string.c:33: int memcmp(const void *lhs, const void *rhs, size_t count) {
                                    135 ;	---------------------------------
                                    136 ; Function memcmp
                                    137 ; ---------------------------------
      00003A                        138 _memcmp::
      00003A DD E5            [15]  139 	push	ix
      00003C DD 21 00 00      [14]  140 	ld	ix,#0
      000040 DD 39            [15]  141 	add	ix,sp
      000042 F5               [11]  142 	push	af
      000043 F5               [11]  143 	push	af
                           000044   144 	C$string.c$34$2_0$26	= .
                                    145 	.globl	C$string.c$34$2_0$26
                                    146 ;string.c:34: const unsigned char *lhs_ = lhs;
      000044 DD 7E 04         [19]  147 	ld	a, 4 (ix)
      000047 DD 77 FC         [19]  148 	ld	-4 (ix), a
      00004A DD 7E 05         [19]  149 	ld	a, 5 (ix)
      00004D DD 77 FD         [19]  150 	ld	-3 (ix), a
                           000050   151 	C$string.c$35$2_0$26	= .
                                    152 	.globl	C$string.c$35$2_0$26
                                    153 ;string.c:35: const unsigned char *rhs_ = rhs;
      000050 DD 7E 06         [19]  154 	ld	a, 6 (ix)
      000053 DD 77 FE         [19]  155 	ld	-2 (ix), a
      000056 DD 7E 07         [19]  156 	ld	a, 7 (ix)
      000059 DD 77 FF         [19]  157 	ld	-1 (ix), a
                           00005C   158 	C$string.c$37$1_0$26	= .
                                    159 	.globl	C$string.c$37$1_0$26
                                    160 ;string.c:37: for (size_t i = 0; i < count; ++i) {
      00005C 01 00 00         [10]  161 	ld	bc, #0x0000
      00005F                        162 00105$:
      00005F 79               [ 4]  163 	ld	a, c
      000060 DD 96 08         [19]  164 	sub	a, 8 (ix)
      000063 78               [ 4]  165 	ld	a, b
      000064 DD 9E 09         [19]  166 	sbc	a, 9 (ix)
      000067 30 1F            [12]  167 	jr	NC, 00103$
                           000069   168 	C$string.c$38$3_0$28	= .
                                    169 	.globl	C$string.c$38$3_0$28
                                    170 ;string.c:38: const int res = lhs_[i] - rhs_[i];
      000069 E1               [10]  171 	pop	hl
      00006A E5               [11]  172 	push	hl
      00006B 09               [11]  173 	add	hl, bc
      00006C 5E               [ 7]  174 	ld	e, (hl)
      00006D 16 00            [ 7]  175 	ld	d, #0x00
      00006F DD 6E FE         [19]  176 	ld	l, -2 (ix)
      000072 DD 66 FF         [19]  177 	ld	h, -1 (ix)
      000075 09               [11]  178 	add	hl, bc
      000076 6E               [ 7]  179 	ld	l, (hl)
                                    180 ;	spillPairReg hl
      000077 26 00            [ 7]  181 	ld	h, #0x00
                                    182 ;	spillPairReg hl
                                    183 ;	spillPairReg hl
      000079 7B               [ 4]  184 	ld	a, e
      00007A 95               [ 4]  185 	sub	a, l
      00007B 5F               [ 4]  186 	ld	e, a
      00007C 7A               [ 4]  187 	ld	a, d
      00007D 9C               [ 4]  188 	sbc	a, h
      00007E 57               [ 4]  189 	ld	d, a
      00007F 6B               [ 4]  190 	ld	l, e
                                    191 ;	spillPairReg hl
                                    192 ;	spillPairReg hl
                                    193 ;	spillPairReg hl
                                    194 ;	spillPairReg hl
                           000080   195 	C$string.c$39$3_0$28	= .
                                    196 	.globl	C$string.c$39$3_0$28
                                    197 ;string.c:39: if (res != 0) {
      000080 7A               [ 4]  198 	ld	a,d
      000081 67               [ 4]  199 	ld	h,a
      000082 B3               [ 4]  200 	or	a, e
                           000083   201 	C$string.c$40$4_0$29	= .
                                    202 	.globl	C$string.c$40$4_0$29
                                    203 ;string.c:40: return res;
      000083 20 06            [12]  204 	jr	NZ, 00107$
                           000085   205 	C$string.c$37$2_0$27	= .
                                    206 	.globl	C$string.c$37$2_0$27
                                    207 ;string.c:37: for (size_t i = 0; i < count; ++i) {
      000085 03               [ 6]  208 	inc	bc
      000086 18 D7            [12]  209 	jr	00105$
      000088                        210 00103$:
                           000088   211 	C$string.c$44$1_0$26	= .
                                    212 	.globl	C$string.c$44$1_0$26
                                    213 ;string.c:44: return 0;
      000088 21 00 00         [10]  214 	ld	hl, #0x0000
      00008B                        215 00107$:
                           00008B   216 	C$string.c$45$1_0$26	= .
                                    217 	.globl	C$string.c$45$1_0$26
                                    218 ;string.c:45: }
      00008B DD F9            [10]  219 	ld	sp, ix
      00008D DD E1            [14]  220 	pop	ix
                           00008F   221 	C$string.c$45$1_0$26	= .
                                    222 	.globl	C$string.c$45$1_0$26
                           00008F   223 	XG$memcmp$0$0	= .
                                    224 	.globl	XG$memcmp$0$0
      00008F C9               [10]  225 	ret
                           000090   226 	G$memcpy$0$0	= .
                                    227 	.globl	G$memcpy$0$0
                           000090   228 	C$string.c$47$1_0$31	= .
                                    229 	.globl	C$string.c$47$1_0$31
                                    230 ;string.c:47: void *memcpy(void *s1, const void *s2, size_t n) {
                                    231 ;	---------------------------------
                                    232 ; Function memcpy
                                    233 ; ---------------------------------
      000090                        234 _memcpy::
      000090 DD E5            [15]  235 	push	ix
      000092 DD 21 00 00      [14]  236 	ld	ix,#0
      000096 DD 39            [15]  237 	add	ix,sp
      000098 F5               [11]  238 	push	af
      000099 F5               [11]  239 	push	af
                           00009A   240 	C$string.c$48$2_0$31	= .
                                    241 	.globl	C$string.c$48$2_0$31
                                    242 ;string.c:48: unsigned char *s1_ = s1;
      00009A DD 4E 04         [19]  243 	ld	c, 4 (ix)
      00009D DD 46 05         [19]  244 	ld	b, 5 (ix)
                           0000A0   245 	C$string.c$49$2_0$31	= .
                                    246 	.globl	C$string.c$49$2_0$31
                                    247 ;string.c:49: const unsigned char *s2_ = s2;
      0000A0 DD 7E 06         [19]  248 	ld	a, 6 (ix)
      0000A3 DD 77 FC         [19]  249 	ld	-4 (ix), a
      0000A6 DD 7E 07         [19]  250 	ld	a, 7 (ix)
      0000A9 DD 77 FD         [19]  251 	ld	-3 (ix), a
                           0000AC   252 	C$string.c$50$1_0$31	= .
                                    253 	.globl	C$string.c$50$1_0$31
                                    254 ;string.c:50: for (size_t i = 0; i < n; ++i) {
      0000AC 11 00 00         [10]  255 	ld	de, #0x0000
      0000AF                        256 00103$:
      0000AF 7B               [ 4]  257 	ld	a, e
      0000B0 DD 96 08         [19]  258 	sub	a, 8 (ix)
      0000B3 7A               [ 4]  259 	ld	a, d
      0000B4 DD 9E 09         [19]  260 	sbc	a, 9 (ix)
      0000B7 30 18            [12]  261 	jr	NC, 00101$
                           0000B9   262 	C$string.c$51$3_0$33	= .
                                    263 	.globl	C$string.c$51$3_0$33
                                    264 ;string.c:51: s1_[i] = s2_[i];
      0000B9 79               [ 4]  265 	ld	a, c
      0000BA 83               [ 4]  266 	add	a, e
      0000BB DD 77 FE         [19]  267 	ld	-2 (ix), a
      0000BE 78               [ 4]  268 	ld	a, b
      0000BF 8A               [ 4]  269 	adc	a, d
      0000C0 DD 77 FF         [19]  270 	ld	-1 (ix), a
      0000C3 E1               [10]  271 	pop	hl
      0000C4 E5               [11]  272 	push	hl
      0000C5 19               [11]  273 	add	hl, de
      0000C6 7E               [ 7]  274 	ld	a, (hl)
      0000C7 DD 6E FE         [19]  275 	ld	l, -2 (ix)
      0000CA DD 66 FF         [19]  276 	ld	h, -1 (ix)
      0000CD 77               [ 7]  277 	ld	(hl), a
                           0000CE   278 	C$string.c$50$2_0$32	= .
                                    279 	.globl	C$string.c$50$2_0$32
                                    280 ;string.c:50: for (size_t i = 0; i < n; ++i) {
      0000CE 13               [ 6]  281 	inc	de
      0000CF 18 DE            [12]  282 	jr	00103$
      0000D1                        283 00101$:
                           0000D1   284 	C$string.c$54$1_0$31	= .
                                    285 	.globl	C$string.c$54$1_0$31
                                    286 ;string.c:54: return s1;
      0000D1 DD 6E 04         [19]  287 	ld	l, 4 (ix)
                                    288 ;	spillPairReg hl
                                    289 ;	spillPairReg hl
      0000D4 DD 66 05         [19]  290 	ld	h, 5 (ix)
                                    291 ;	spillPairReg hl
                                    292 ;	spillPairReg hl
                           0000D7   293 	C$string.c$55$1_0$31	= .
                                    294 	.globl	C$string.c$55$1_0$31
                                    295 ;string.c:55: }
      0000D7 DD F9            [10]  296 	ld	sp, ix
      0000D9 DD E1            [14]  297 	pop	ix
                           0000DB   298 	C$string.c$55$1_0$31	= .
                                    299 	.globl	C$string.c$55$1_0$31
                           0000DB   300 	XG$memcpy$0$0	= .
                                    301 	.globl	XG$memcpy$0$0
      0000DB C9               [10]  302 	ret
                           0000DC   303 	G$memset$0$0	= .
                                    304 	.globl	G$memset$0$0
                           0000DC   305 	C$string.c$57$1_0$35	= .
                                    306 	.globl	C$string.c$57$1_0$35
                                    307 ;string.c:57: void *memset(void *s, int c, size_t n) {
                                    308 ;	---------------------------------
                                    309 ; Function memset
                                    310 ; ---------------------------------
      0000DC                        311 _memset::
      0000DC DD E5            [15]  312 	push	ix
      0000DE DD 21 00 00      [14]  313 	ld	ix,#0
      0000E2 DD 39            [15]  314 	add	ix,sp
      0000E4 3B               [ 6]  315 	dec	sp
                           0000E5   316 	C$string.c$58$2_0$35	= .
                                    317 	.globl	C$string.c$58$2_0$35
                                    318 ;string.c:58: unsigned char *s_ = s;
      0000E5 DD 4E 04         [19]  319 	ld	c, 4 (ix)
      0000E8 DD 46 05         [19]  320 	ld	b, 5 (ix)
                           0000EB   321 	C$string.c$59$1_0$35	= .
                                    322 	.globl	C$string.c$59$1_0$35
                                    323 ;string.c:59: const unsigned char c_ = (unsigned char)c;
      0000EB DD 7E 06         [19]  324 	ld	a, 6 (ix)
      0000EE DD 77 FF         [19]  325 	ld	-1 (ix), a
                           0000F1   326 	C$string.c$60$1_0$35	= .
                                    327 	.globl	C$string.c$60$1_0$35
                                    328 ;string.c:60: for (size_t i = 0; i < n; ++i) {
      0000F1 11 00 00         [10]  329 	ld	de, #0x0000
      0000F4                        330 00103$:
      0000F4 7B               [ 4]  331 	ld	a, e
      0000F5 DD 96 08         [19]  332 	sub	a, 8 (ix)
      0000F8 7A               [ 4]  333 	ld	a, d
      0000F9 DD 9E 09         [19]  334 	sbc	a, 9 (ix)
      0000FC 30 0A            [12]  335 	jr	NC, 00101$
                           0000FE   336 	C$string.c$61$3_0$37	= .
                                    337 	.globl	C$string.c$61$3_0$37
                                    338 ;string.c:61: s_[i] = c_;
      0000FE 69               [ 4]  339 	ld	l, c
      0000FF 60               [ 4]  340 	ld	h, b
      000100 19               [11]  341 	add	hl, de
      000101 DD 7E FF         [19]  342 	ld	a, -1 (ix)
      000104 77               [ 7]  343 	ld	(hl), a
                           000105   344 	C$string.c$60$2_0$36	= .
                                    345 	.globl	C$string.c$60$2_0$36
                                    346 ;string.c:60: for (size_t i = 0; i < n; ++i) {
      000105 13               [ 6]  347 	inc	de
      000106 18 EC            [12]  348 	jr	00103$
      000108                        349 00101$:
                           000108   350 	C$string.c$63$1_0$35	= .
                                    351 	.globl	C$string.c$63$1_0$35
                                    352 ;string.c:63: return s;
      000108 DD 6E 04         [19]  353 	ld	l, 4 (ix)
                                    354 ;	spillPairReg hl
                                    355 ;	spillPairReg hl
      00010B DD 66 05         [19]  356 	ld	h, 5 (ix)
                                    357 ;	spillPairReg hl
                                    358 ;	spillPairReg hl
                           00010E   359 	C$string.c$64$1_0$35	= .
                                    360 	.globl	C$string.c$64$1_0$35
                                    361 ;string.c:64: }
      00010E 33               [ 6]  362 	inc	sp
      00010F DD E1            [14]  363 	pop	ix
                           000111   364 	C$string.c$64$1_0$35	= .
                                    365 	.globl	C$string.c$64$1_0$35
                           000111   366 	XG$memset$0$0	= .
                                    367 	.globl	XG$memset$0$0
      000111 C9               [10]  368 	ret
                           000112   369 	G$strlen$0$0	= .
                                    370 	.globl	G$strlen$0$0
                           000112   371 	C$string.c$66$1_0$39	= .
                                    372 	.globl	C$string.c$66$1_0$39
                                    373 ;string.c:66: size_t strlen(const char *str)
                                    374 ;	---------------------------------
                                    375 ; Function strlen
                                    376 ; ---------------------------------
      000112                        377 _strlen::
                           000112   378 	C$string.c$70$1_0$39	= .
                                    379 	.globl	C$string.c$70$1_0$39
                                    380 ;string.c:70: while (*str++)
      000112 01 00 00         [10]  381 	ld	bc, #0x0000
      000115 E1               [10]  382 	pop	hl
      000116 D1               [10]  383 	pop	de
      000117 D5               [11]  384 	push	de
      000118 E5               [11]  385 	push	hl
      000119                        386 00101$:
      000119 1A               [ 7]  387 	ld	a, (de)
      00011A 13               [ 6]  388 	inc	de
      00011B B7               [ 4]  389 	or	a, a
      00011C 28 03            [12]  390 	jr	Z, 00103$
                           00011E   391 	C$string.c$71$1_0$39	= .
                                    392 	.globl	C$string.c$71$1_0$39
                                    393 ;string.c:71: length++;
      00011E 03               [ 6]  394 	inc	bc
      00011F 18 F8            [12]  395 	jr	00101$
      000121                        396 00103$:
                           000121   397 	C$string.c$73$1_0$39	= .
                                    398 	.globl	C$string.c$73$1_0$39
                                    399 ;string.c:73: return (length);
      000121 69               [ 4]  400 	ld	l, c
                                    401 ;	spillPairReg hl
                                    402 ;	spillPairReg hl
      000122 60               [ 4]  403 	ld	h, b
                                    404 ;	spillPairReg hl
                                    405 ;	spillPairReg hl
                           000123   406 	C$string.c$74$1_0$39	= .
                                    407 	.globl	C$string.c$74$1_0$39
                                    408 ;string.c:74: }
                           000123   409 	C$string.c$74$1_0$39	= .
                                    410 	.globl	C$string.c$74$1_0$39
                           000123   411 	XG$strlen$0$0	= .
                                    412 	.globl	XG$strlen$0$0
      000123 C9               [10]  413 	ret
                           000124   414 	G$strcpy$0$0	= .
                                    415 	.globl	G$strcpy$0$0
                           000124   416 	C$string.c$76$1_0$41	= .
                                    417 	.globl	C$string.c$76$1_0$41
                                    418 ;string.c:76: char *strcpy(char *dest, const char *src)
                                    419 ;	---------------------------------
                                    420 ; Function strcpy
                                    421 ; ---------------------------------
      000124                        422 _strcpy::
                           000124   423 	C$string.c$80$1_0$41	= .
                                    424 	.globl	C$string.c$80$1_0$41
                                    425 ;string.c:80: while (src[index])
      000124 01 00 00         [10]  426 	ld	bc, #0x0000
      000127                        427 00101$:
      000127 FD 21 04 00      [14]  428 	ld	iy, #4
      00012B FD 39            [15]  429 	add	iy, sp
      00012D FD 6E 00         [19]  430 	ld	l, 0 (iy)
      000130 FD 66 01         [19]  431 	ld	h, 1 (iy)
      000133 09               [11]  432 	add	hl, bc
      000134 5E               [ 7]  433 	ld	e, (hl)
      000135 7B               [ 4]  434 	ld	a, e
      000136 B7               [ 4]  435 	or	a, a
      000137 28 13            [12]  436 	jr	Z, 00103$
                           000139   437 	C$string.c$82$2_0$42	= .
                                    438 	.globl	C$string.c$82$2_0$42
                                    439 ;string.c:82: dest[index] = src[index];
      000139 FD 7E FE         [19]  440 	ld	a, -2 (iy)
      00013C FD 2B            [10]  441 	dec	iy
      00013E FD 2B            [10]  442 	dec	iy
      000140 81               [ 4]  443 	add	a, c
      000141 57               [ 4]  444 	ld	d, a
      000142 FD 7E 01         [19]  445 	ld	a, 1 (iy)
      000145 88               [ 4]  446 	adc	a, b
      000146 6A               [ 4]  447 	ld	l, d
      000147 67               [ 4]  448 	ld	h, a
      000148 73               [ 7]  449 	ld	(hl), e
                           000149   450 	C$string.c$83$2_0$42	= .
                                    451 	.globl	C$string.c$83$2_0$42
                                    452 ;string.c:83: index++;
      000149 03               [ 6]  453 	inc	bc
      00014A 18 DB            [12]  454 	jr	00101$
      00014C                        455 00103$:
                           00014C   456 	C$string.c$86$1_0$41	= .
                                    457 	.globl	C$string.c$86$1_0$41
                                    458 ;string.c:86: return (dest);
      00014C D1               [10]  459 	pop	de
      00014D E1               [10]  460 	pop	hl
      00014E E5               [11]  461 	push	hl
      00014F D5               [11]  462 	push	de
                           000150   463 	C$string.c$87$1_0$41	= .
                                    464 	.globl	C$string.c$87$1_0$41
                                    465 ;string.c:87: }
                           000150   466 	C$string.c$87$1_0$41	= .
                                    467 	.globl	C$string.c$87$1_0$41
                           000150   468 	XG$strcpy$0$0	= .
                                    469 	.globl	XG$strcpy$0$0
      000150 C9               [10]  470 	ret
                           000151   471 	G$strncpy$0$0	= .
                                    472 	.globl	G$strncpy$0$0
                           000151   473 	C$string.c$89$1_0$44	= .
                                    474 	.globl	C$string.c$89$1_0$44
                                    475 ;string.c:89: char* strncpy(char* dst, const char* src, size_t num)
                                    476 ;	---------------------------------
                                    477 ; Function strncpy
                                    478 ; ---------------------------------
      000151                        479 _strncpy::
      000151 DD E5            [15]  480 	push	ix
      000153 DD 21 00 00      [14]  481 	ld	ix,#0
      000157 DD 39            [15]  482 	add	ix,sp
      000159 F5               [11]  483 	push	af
      00015A 3B               [ 6]  484 	dec	sp
                           00015B   485 	C$string.c$91$1_0$44	= .
                                    486 	.globl	C$string.c$91$1_0$44
                                    487 ;string.c:91: if (dst == NULL) {
      00015B DD 7E 05         [19]  488 	ld	a, 5 (ix)
      00015E DD B6 04         [19]  489 	or	a, 4 (ix)
      000161 20 05            [12]  490 	jr	NZ, 00102$
                           000163   491 	C$string.c$92$2_0$45	= .
                                    492 	.globl	C$string.c$92$2_0$45
                                    493 ;string.c:92: return NULL;
      000163 21 00 00         [10]  494 	ld	hl, #0x0000
      000166 18 4A            [12]  495 	jr	00107$
      000168                        496 00102$:
                           000168   497 	C$string.c$94$2_0$46	= .
                                    498 	.globl	C$string.c$94$2_0$46
                                    499 ;string.c:94: char* ptr = dst;
      000168 DD 5E 04         [19]  500 	ld	e, 4 (ix)
      00016B DD 56 05         [19]  501 	ld	d, 5 (ix)
                           00016E   502 	C$string.c$95$1_1$44	= .
                                    503 	.globl	C$string.c$95$1_1$44
                                    504 ;string.c:95: while (*src && num--)
      00016E FD E5            [15]  505 	push	iy
      000170 E3               [19]  506 	ex	(sp), hl
      000171 DD 6E 08         [19]  507 	ld	l, 8 (ix)
                                    508 ;	spillPairReg hl
                                    509 ;	spillPairReg hl
      000174 E3               [19]  510 	ex	(sp), hl
      000175 E3               [19]  511 	ex	(sp), hl
      000176 DD 66 09         [19]  512 	ld	h, 9 (ix)
                                    513 ;	spillPairReg hl
                                    514 ;	spillPairReg hl
      000179 E3               [19]  515 	ex	(sp), hl
      00017A FD E1            [14]  516 	pop	iy
      00017C 4B               [ 4]  517 	ld	c, e
      00017D 42               [ 4]  518 	ld	b, d
      00017E DD 7E 06         [19]  519 	ld	a, 6 (ix)
      000181 DD 77 FE         [19]  520 	ld	-2 (ix), a
      000184 DD 7E 07         [19]  521 	ld	a, 7 (ix)
      000187 DD 77 FF         [19]  522 	ld	-1 (ix), a
      00018A                        523 00104$:
      00018A DD 6E FE         [19]  524 	ld	l, -2 (ix)
      00018D DD 66 FF         [19]  525 	ld	h, -1 (ix)
      000190 7E               [ 7]  526 	ld	a, (hl)
      000191 DD 77 FD         [19]  527 	ld	-3 (ix), a
      000194 B7               [ 4]  528 	or	a, a
      000195 28 18            [12]  529 	jr	Z, 00106$
      000197 FD E5            [15]  530 	push	iy
      000199 E1               [10]  531 	pop	hl
      00019A FD 2B            [10]  532 	dec	iy
      00019C 7C               [ 4]  533 	ld	a, h
      00019D B5               [ 4]  534 	or	a, l
      00019E 28 0F            [12]  535 	jr	Z, 00106$
                           0001A0   536 	C$string.c$97$2_1$47	= .
                                    537 	.globl	C$string.c$97$2_1$47
                                    538 ;string.c:97: *dst = *src;
      0001A0 DD 7E FD         [19]  539 	ld	a, -3 (ix)
      0001A3 02               [ 7]  540 	ld	(bc), a
                           0001A4   541 	C$string.c$98$2_1$47	= .
                                    542 	.globl	C$string.c$98$2_1$47
                                    543 ;string.c:98: dst++;
      0001A4 03               [ 6]  544 	inc	bc
                           0001A5   545 	C$string.c$99$2_1$47	= .
                                    546 	.globl	C$string.c$99$2_1$47
                                    547 ;string.c:99: src++;
      0001A5 DD 34 FE         [23]  548 	inc	-2 (ix)
      0001A8 20 E0            [12]  549 	jr	NZ, 00104$
      0001AA DD 34 FF         [23]  550 	inc	-1 (ix)
      0001AD 18 DB            [12]  551 	jr	00104$
      0001AF                        552 00106$:
                           0001AF   553 	C$string.c$101$1_1$46	= .
                                    554 	.globl	C$string.c$101$1_1$46
                                    555 ;string.c:101: *dst = '\0';
      0001AF AF               [ 4]  556 	xor	a, a
      0001B0 02               [ 7]  557 	ld	(bc), a
                           0001B1   558 	C$string.c$102$1_1$46	= .
                                    559 	.globl	C$string.c$102$1_1$46
                                    560 ;string.c:102: return ptr;
      0001B1 EB               [ 4]  561 	ex	de, hl
      0001B2                        562 00107$:
                           0001B2   563 	C$string.c$103$1_1$44	= .
                                    564 	.globl	C$string.c$103$1_1$44
                                    565 ;string.c:103: }
      0001B2 DD F9            [10]  566 	ld	sp, ix
      0001B4 DD E1            [14]  567 	pop	ix
                           0001B6   568 	C$string.c$103$1_1$44	= .
                                    569 	.globl	C$string.c$103$1_1$44
                           0001B6   570 	XG$strncpy$0$0	= .
                                    571 	.globl	XG$strncpy$0$0
      0001B6 C9               [10]  572 	ret
                           0001B7   573 	G$strcmp$0$0	= .
                                    574 	.globl	G$strcmp$0$0
                           0001B7   575 	C$string.c$105$1_1$49	= .
                                    576 	.globl	C$string.c$105$1_1$49
                                    577 ;string.c:105: int strcmp(const char *s1, const char *s2) {
                                    578 ;	---------------------------------
                                    579 ; Function strcmp
                                    580 ; ---------------------------------
      0001B7                        581 _strcmp::
      0001B7 DD E5            [15]  582 	push	ix
      0001B9 DD 21 00 00      [14]  583 	ld	ix,#0
      0001BD DD 39            [15]  584 	add	ix,sp
                           0001BF   585 	C$string.c$106$1_0$49	= .
                                    586 	.globl	C$string.c$106$1_0$49
                                    587 ;string.c:106: while (*s1 && *s2 && *s1 == *s2)
      0001BF DD 4E 04         [19]  588 	ld	c, 4 (ix)
      0001C2 DD 46 05         [19]  589 	ld	b, 5 (ix)
      0001C5 DD 6E 06         [19]  590 	ld	l, 6 (ix)
                                    591 ;	spillPairReg hl
                                    592 ;	spillPairReg hl
      0001C8 DD 66 07         [19]  593 	ld	h, 7 (ix)
                                    594 ;	spillPairReg hl
                                    595 ;	spillPairReg hl
      0001CB                        596 00103$:
      0001CB 0A               [ 7]  597 	ld	a, (bc)
      0001CC 5E               [ 7]  598 	ld	e, (hl)
      0001CD B7               [ 4]  599 	or	a, a
      0001CE 28 0B            [12]  600 	jr	Z, 00105$
      0001D0 1C               [ 4]  601 	inc	e
      0001D1 1D               [ 4]  602 	dec	e
      0001D2 28 07            [12]  603 	jr	Z, 00105$
      0001D4 BB               [ 4]  604 	cp	a, e
      0001D5 20 04            [12]  605 	jr	NZ, 00105$
                           0001D7   606 	C$string.c$108$2_0$50	= .
                                    607 	.globl	C$string.c$108$2_0$50
                                    608 ;string.c:108: s1++;
                           0001D7   609 	C$string.c$109$2_0$50	= .
                                    610 	.globl	C$string.c$109$2_0$50
                                    611 ;string.c:109: s2++;
      0001D7 23               [ 6]  612 	inc	hl
      0001D8 03               [ 6]  613 	inc	bc
      0001D9 18 F0            [12]  614 	jr	00103$
      0001DB                        615 00105$:
                           0001DB   616 	C$string.c$111$1_0$49	= .
                                    617 	.globl	C$string.c$111$1_0$49
                                    618 ;string.c:111: return (*s1 - *s2);
      0001DB 6F               [ 4]  619 	ld	l, a
                                    620 ;	spillPairReg hl
                                    621 ;	spillPairReg hl
                                    622 ;	spillPairReg hl
                                    623 ;	spillPairReg hl
      0001DC 26 00            [ 7]  624 	ld	h, #0x00
      0001DE 54               [ 4]  625 	ld	d, h
      0001DF BF               [ 4]  626 	cp	a, a
      0001E0 ED 52            [15]  627 	sbc	hl, de
                           0001E2   628 	C$string.c$112$1_0$49	= .
                                    629 	.globl	C$string.c$112$1_0$49
                                    630 ;string.c:112: }
      0001E2 DD E1            [14]  631 	pop	ix
                           0001E4   632 	C$string.c$112$1_0$49	= .
                                    633 	.globl	C$string.c$112$1_0$49
                           0001E4   634 	XG$strcmp$0$0	= .
                                    635 	.globl	XG$strcmp$0$0
      0001E4 C9               [10]  636 	ret
                           0001E5   637 	G$strncmp$0$0	= .
                                    638 	.globl	G$strncmp$0$0
                           0001E5   639 	C$string.c$114$1_0$52	= .
                                    640 	.globl	C$string.c$114$1_0$52
                                    641 ;string.c:114: int strncmp(const char *s1, const char *s2, register size_t n)
                                    642 ;	---------------------------------
                                    643 ; Function strncmp
                                    644 ; ---------------------------------
      0001E5                        645 _strncmp::
      0001E5 DD E5            [15]  646 	push	ix
      0001E7 DD 21 00 00      [14]  647 	ld	ix,#0
      0001EB DD 39            [15]  648 	add	ix,sp
      0001ED 21 F8 FF         [10]  649 	ld	hl, #-8
      0001F0 39               [11]  650 	add	hl, sp
      0001F1 F9               [ 6]  651 	ld	sp, hl
                           0001F2   652 	C$string.c$117$1_0$52	= .
                                    653 	.globl	C$string.c$117$1_0$52
                                    654 ;string.c:117: while (n-- > 0)
      0001F2 DD 7E 04         [19]  655 	ld	a, 4 (ix)
      0001F5 DD 77 FA         [19]  656 	ld	-6 (ix), a
      0001F8 DD 7E 05         [19]  657 	ld	a, 5 (ix)
      0001FB DD 77 FB         [19]  658 	ld	-5 (ix), a
      0001FE DD 7E 06         [19]  659 	ld	a, 6 (ix)
      000201 DD 77 FC         [19]  660 	ld	-4 (ix), a
      000204 DD 7E 07         [19]  661 	ld	a, 7 (ix)
      000207 DD 77 FD         [19]  662 	ld	-3 (ix), a
      00020A DD 7E 08         [19]  663 	ld	a, 8 (ix)
      00020D DD 77 FE         [19]  664 	ld	-2 (ix), a
      000210 DD 7E 09         [19]  665 	ld	a, 9 (ix)
      000213 DD 77 FF         [19]  666 	ld	-1 (ix), a
      000216                        667 00105$:
      000216 DD 7E FE         [19]  668 	ld	a, -2 (ix)
      000219 DD 77 F8         [19]  669 	ld	-8 (ix), a
      00021C DD 7E FF         [19]  670 	ld	a, -1 (ix)
      00021F DD 77 F9         [19]  671 	ld	-7 (ix), a
      000222 DD 6E FE         [19]  672 	ld	l, -2 (ix)
      000225 DD 66 FF         [19]  673 	ld	h, -1 (ix)
      000228 2B               [ 6]  674 	dec	hl
      000229 DD 75 FE         [19]  675 	ld	-2 (ix), l
      00022C DD 74 FF         [19]  676 	ld	-1 (ix), h
      00022F DD 7E F9         [19]  677 	ld	a, -7 (ix)
      000232 DD B6 F8         [19]  678 	or	a, -8 (ix)
      000235 28 64            [12]  679 	jr	Z, 00107$
                           000237   680 	C$string.c$119$2_0$53	= .
                                    681 	.globl	C$string.c$119$2_0$53
                                    682 ;string.c:119: u1 = (unsigned char) *s1++;
      000237 DD 6E FA         [19]  683 	ld	l, -6 (ix)
      00023A DD 66 FB         [19]  684 	ld	h, -5 (ix)
      00023D 7E               [ 7]  685 	ld	a, (hl)
      00023E DD 77 F8         [19]  686 	ld	-8 (ix), a
      000241 DD 34 FA         [23]  687 	inc	-6 (ix)
      000244 20 03            [12]  688 	jr	NZ, 00130$
      000246 DD 34 FB         [23]  689 	inc	-5 (ix)
      000249                        690 00130$:
                           000249   691 	C$string.c$120$2_0$53	= .
                                    692 	.globl	C$string.c$120$2_0$53
                                    693 ;string.c:120: u2 = (unsigned char) *s2++;
      000249 DD 6E FC         [19]  694 	ld	l, -4 (ix)
      00024C DD 66 FD         [19]  695 	ld	h, -3 (ix)
      00024F 7E               [ 7]  696 	ld	a, (hl)
      000250 DD 77 F9         [19]  697 	ld	-7 (ix), a
      000253 DD 34 FC         [23]  698 	inc	-4 (ix)
      000256 20 03            [12]  699 	jr	NZ, 00131$
      000258 DD 34 FD         [23]  700 	inc	-3 (ix)
      00025B                        701 00131$:
                           00025B   702 	C$string.c$121$2_0$53	= .
                                    703 	.globl	C$string.c$121$2_0$53
                                    704 ;string.c:121: if (u1 != u2)
      00025B DD 7E F8         [19]  705 	ld	a, -8 (ix)
      00025E DD 96 F9         [19]  706 	sub	a, -7 (ix)
      000261 28 2C            [12]  707 	jr	Z, 00102$
                           000263   708 	C$string.c$122$2_0$53	= .
                                    709 	.globl	C$string.c$122$2_0$53
                                    710 ;string.c:122: return u1 - u2;
      000263 DD 7E F8         [19]  711 	ld	a, -8 (ix)
      000266 DD 77 FE         [19]  712 	ld	-2 (ix), a
      000269 DD 36 FF 00      [19]  713 	ld	-1 (ix), #0x00
      00026D DD 7E F9         [19]  714 	ld	a, -7 (ix)
      000270 DD 77 FC         [19]  715 	ld	-4 (ix), a
      000273 DD 36 FD 00      [19]  716 	ld	-3 (ix), #0x00
      000277 DD 7E FE         [19]  717 	ld	a, -2 (ix)
      00027A DD 96 FC         [19]  718 	sub	a, -4 (ix)
      00027D DD 77 FA         [19]  719 	ld	-6 (ix), a
      000280 DD 7E FF         [19]  720 	ld	a, -1 (ix)
      000283 DD 9E FD         [19]  721 	sbc	a, -3 (ix)
      000286 DD 77 FB         [19]  722 	ld	-5 (ix), a
      000289 D1               [10]  723 	pop	de
      00028A E1               [10]  724 	pop	hl
      00028B E5               [11]  725 	push	hl
      00028C D5               [11]  726 	push	de
      00028D 18 0F            [12]  727 	jr	00108$
      00028F                        728 00102$:
                           00028F   729 	C$string.c$123$2_0$53	= .
                                    730 	.globl	C$string.c$123$2_0$53
                                    731 ;string.c:123: if (u1 == '\0')
      00028F DD 7E F8         [19]  732 	ld	a, -8 (ix)
      000292 B7               [ 4]  733 	or	a, a
      000293 C2r16r02         [10]  734 	jp	NZ, 00105$
                           000296   735 	C$string.c$124$2_0$53	= .
                                    736 	.globl	C$string.c$124$2_0$53
                                    737 ;string.c:124: return 0;
      000296 21 00 00         [10]  738 	ld	hl, #0x0000
      000299 18 03            [12]  739 	jr	00108$
      00029B                        740 00107$:
                           00029B   741 	C$string.c$126$1_0$52	= .
                                    742 	.globl	C$string.c$126$1_0$52
                                    743 ;string.c:126: return 0;
      00029B 21 00 00         [10]  744 	ld	hl, #0x0000
      00029E                        745 00108$:
                           00029E   746 	C$string.c$127$1_0$52	= .
                                    747 	.globl	C$string.c$127$1_0$52
                                    748 ;string.c:127: }
      00029E DD F9            [10]  749 	ld	sp, ix
      0002A0 DD E1            [14]  750 	pop	ix
                           0002A2   751 	C$string.c$127$1_0$52	= .
                                    752 	.globl	C$string.c$127$1_0$52
                           0002A2   753 	XG$strncmp$0$0	= .
                                    754 	.globl	XG$strncmp$0$0
      0002A2 C9               [10]  755 	ret
                           0002A3   756 	G$strchr$0$0	= .
                                    757 	.globl	G$strchr$0$0
                           0002A3   758 	C$string.c$129$1_0$55	= .
                                    759 	.globl	C$string.c$129$1_0$55
                                    760 ;string.c:129: char *strchr(const char *s, int c) {
                                    761 ;	---------------------------------
                                    762 ; Function strchr
                                    763 ; ---------------------------------
      0002A3                        764 _strchr::
                           0002A3   765 	C$string.c$130$1_0$55	= .
                                    766 	.globl	C$string.c$130$1_0$55
                                    767 ;string.c:130: const char c_ = (char)c;
      0002A3 21 04 00         [10]  768 	ld	hl, #4
      0002A6 39               [11]  769 	add	hl, sp
      0002A7 4E               [ 7]  770 	ld	c, (hl)
                           0002A8   771 	C$string.c$131$1_0$55	= .
                                    772 	.globl	C$string.c$131$1_0$55
                                    773 ;string.c:131: do {
      0002A8 D1               [10]  774 	pop	de
      0002A9 E1               [10]  775 	pop	hl
      0002AA E5               [11]  776 	push	hl
      0002AB D5               [11]  777 	push	de
      0002AC                        778 00103$:
                           0002AC   779 	C$string.c$132$2_0$56	= .
                                    780 	.globl	C$string.c$132$2_0$56
                                    781 ;string.c:132: if (*s == c_) {
      0002AC 46               [ 7]  782 	ld	b, (hl)
      0002AD 79               [ 4]  783 	ld	a, c
      0002AE 90               [ 4]  784 	sub	a, b
      0002AF C8               [11]  785 	ret	Z
                           0002B0   786 	C$string.c$133$3_0$57	= .
                                    787 	.globl	C$string.c$133$3_0$57
                                    788 ;string.c:133: return (char *)s;
      0002B0 18 00            [12]  789 	jr	00104$
      0002B2                        790 00104$:
                           0002B2   791 	C$string.c$135$1_0$55	= .
                                    792 	.globl	C$string.c$135$1_0$55
                                    793 ;string.c:135: } while (*s++ != '\0');
      0002B2 23               [ 6]  794 	inc	hl
      0002B3 78               [ 4]  795 	ld	a, b
      0002B4 B7               [ 4]  796 	or	a, a
      0002B5 20 F5            [12]  797 	jr	NZ, 00103$
                           0002B7   798 	C$string.c$136$1_0$55	= .
                                    799 	.globl	C$string.c$136$1_0$55
                                    800 ;string.c:136: return NULL;
      0002B7 21 00 00         [10]  801 	ld	hl, #0x0000
                           0002BA   802 	C$string.c$137$1_0$55	= .
                                    803 	.globl	C$string.c$137$1_0$55
                                    804 ;string.c:137: }
                           0002BA   805 	C$string.c$137$1_0$55	= .
                                    806 	.globl	C$string.c$137$1_0$55
                           0002BA   807 	XG$strchr$0$0	= .
                                    808 	.globl	XG$strchr$0$0
      0002BA C9               [10]  809 	ret
                           0002BB   810 	G$strrchr$0$0	= .
                                    811 	.globl	G$strrchr$0$0
                           0002BB   812 	C$string.c$139$1_0$59	= .
                                    813 	.globl	C$string.c$139$1_0$59
                                    814 ;string.c:139: char *strrchr(char *s, int c)
                                    815 ;	---------------------------------
                                    816 ; Function strrchr
                                    817 ; ---------------------------------
      0002BB                        818 _strrchr::
      0002BB DD E5            [15]  819 	push	ix
      0002BD DD 21 00 00      [14]  820 	ld	ix,#0
      0002C1 DD 39            [15]  821 	add	ix,sp
                           0002C3   822 	C$string.c$141$1_0$59	= .
                                    823 	.globl	C$string.c$141$1_0$59
                                    824 ;string.c:141: char *ptr = (const char *) s;
      0002C3 DD 4E 04         [19]  825 	ld	c, 4 (ix)
      0002C6 DD 46 05         [19]  826 	ld	b, 5 (ix)
                           0002C9   827 	C$string.c$142$1_0$59	= .
                                    828 	.globl	C$string.c$142$1_0$59
                                    829 ;string.c:142: char *retptr = NULL;
      0002C9 21 00 00         [10]  830 	ld	hl, #0x0000
                           0002CC   831 	C$string.c$144$1_0$59	= .
                                    832 	.globl	C$string.c$144$1_0$59
                                    833 ;string.c:144: while (ptr[0] != '\0') {
      0002CC                        834 00103$:
      0002CC 0A               [ 7]  835 	ld	a, (bc)
      0002CD B7               [ 4]  836 	or	a, a
      0002CE 28 14            [12]  837 	jr	Z, 00105$
                           0002D0   838 	C$string.c$145$2_0$60	= .
                                    839 	.globl	C$string.c$145$2_0$60
                                    840 ;string.c:145: if (ptr[0] == c) {
      0002D0 5F               [ 4]  841 	ld	e, a
      0002D1 16 00            [ 7]  842 	ld	d, #0x00
      0002D3 DD 7E 06         [19]  843 	ld	a, 6 (ix)
      0002D6 93               [ 4]  844 	sub	a, e
      0002D7 20 08            [12]  845 	jr	NZ, 00102$
      0002D9 DD 7E 07         [19]  846 	ld	a, 7 (ix)
      0002DC 92               [ 4]  847 	sub	a, d
      0002DD 20 02            [12]  848 	jr	NZ, 00102$
                           0002DF   849 	C$string.c$146$3_0$61	= .
                                    850 	.globl	C$string.c$146$3_0$61
                                    851 ;string.c:146: retptr = (char *) ptr;
      0002DF 69               [ 4]  852 	ld	l, c
                                    853 ;	spillPairReg hl
                                    854 ;	spillPairReg hl
      0002E0 60               [ 4]  855 	ld	h, b
                                    856 ;	spillPairReg hl
                                    857 ;	spillPairReg hl
      0002E1                        858 00102$:
                           0002E1   859 	C$string.c$148$2_0$60	= .
                                    860 	.globl	C$string.c$148$2_0$60
                                    861 ;string.c:148: ptr ++;
      0002E1 03               [ 6]  862 	inc	bc
      0002E2 18 E8            [12]  863 	jr	00103$
      0002E4                        864 00105$:
                           0002E4   865 	C$string.c$150$1_0$59	= .
                                    866 	.globl	C$string.c$150$1_0$59
                                    867 ;string.c:150: return retptr;
                           0002E4   868 	C$string.c$151$1_0$59	= .
                                    869 	.globl	C$string.c$151$1_0$59
                                    870 ;string.c:151: }
      0002E4 DD E1            [14]  871 	pop	ix
                           0002E6   872 	C$string.c$151$1_0$59	= .
                                    873 	.globl	C$string.c$151$1_0$59
                           0002E6   874 	XG$strrchr$0$0	= .
                                    875 	.globl	XG$strrchr$0$0
      0002E6 C9               [10]  876 	ret
                           0002E7   877 	G$strsep$0$0	= .
                                    878 	.globl	G$strsep$0$0
                           0002E7   879 	C$string.c$153$1_0$63	= .
                                    880 	.globl	C$string.c$153$1_0$63
                                    881 ;string.c:153: char * strsep(char **stringp, const char *delim)
                                    882 ;	---------------------------------
                                    883 ; Function strsep
                                    884 ; ---------------------------------
      0002E7                        885 _strsep::
      0002E7 DD E5            [15]  886 	push	ix
      0002E9 DD 21 00 00      [14]  887 	ld	ix,#0
      0002ED DD 39            [15]  888 	add	ix,sp
      0002EF 21 F4 FF         [10]  889 	ld	hl, #-12
      0002F2 39               [11]  890 	add	hl, sp
      0002F3 F9               [ 6]  891 	ld	sp, hl
                           0002F4   892 	C$string.c$159$1_0$63	= .
                                    893 	.globl	C$string.c$159$1_0$63
                                    894 ;string.c:159: if ((s = *stringp) == NULL)
      0002F4 DD 7E 04         [19]  895 	ld	a, 4 (ix)
      0002F7 DD 77 F4         [19]  896 	ld	-12 (ix), a
      0002FA DD 7E 05         [19]  897 	ld	a, 5 (ix)
      0002FD DD 77 F5         [19]  898 	ld	-11 (ix), a
      000300 E1               [10]  899 	pop	hl
      000301 E5               [11]  900 	push	hl
      000302 7E               [ 7]  901 	ld	a, (hl)
      000303 DD 77 FC         [19]  902 	ld	-4 (ix), a
      000306 23               [ 6]  903 	inc	hl
      000307 7E               [ 7]  904 	ld	a, (hl)
      000308 DD 77 FD         [19]  905 	ld	-3 (ix), a
      00030B DD 7E FC         [19]  906 	ld	a, -4 (ix)
      00030E DD 77 FE         [19]  907 	ld	-2 (ix), a
      000311 DD 7E FD         [19]  908 	ld	a, -3 (ix)
      000314 DD 77 FF         [19]  909 	ld	-1 (ix), a
      000317 DD 7E FD         [19]  910 	ld	a, -3 (ix)
      00031A DD B6 FC         [19]  911 	or	a, -4 (ix)
      00031D 20 06            [12]  912 	jr	NZ, 00102$
                           00031F   913 	C$string.c$160$1_0$63	= .
                                    914 	.globl	C$string.c$160$1_0$63
                                    915 ;string.c:160: return (NULL);
      00031F 21 00 00         [10]  916 	ld	hl, #0x0000
      000322 C3rB5r03         [10]  917 	jp	00114$
      000325                        918 00102$:
                           000325   919 	C$string.c$161$2_0$64	= .
                                    920 	.globl	C$string.c$161$2_0$64
                                    921 ;string.c:161: for (tok = s;;) {
      000325 DD 7E FE         [19]  922 	ld	a, -2 (ix)
      000328 DD 77 F6         [19]  923 	ld	-10 (ix), a
      00032B DD 7E FF         [19]  924 	ld	a, -1 (ix)
      00032E DD 77 F7         [19]  925 	ld	-9 (ix), a
      000331 DD 7E FE         [19]  926 	ld	a, -2 (ix)
      000334 DD 77 FC         [19]  927 	ld	-4 (ix), a
      000337 DD 7E FF         [19]  928 	ld	a, -1 (ix)
      00033A DD 77 FD         [19]  929 	ld	-3 (ix), a
      00033D                        930 00112$:
                           00033D   931 	C$string.c$162$3_0$65	= .
                                    932 	.globl	C$string.c$162$3_0$65
                                    933 ;string.c:162: c = *s++;
      00033D DD 6E FC         [19]  934 	ld	l, -4 (ix)
      000340 DD 66 FD         [19]  935 	ld	h, -3 (ix)
      000343 7E               [ 7]  936 	ld	a, (hl)
      000344 DD 34 FC         [23]  937 	inc	-4 (ix)
      000347 20 03            [12]  938 	jr	NZ, 00148$
      000349 DD 34 FD         [23]  939 	inc	-3 (ix)
      00034C                        940 00148$:
      00034C DD 77 F8         [19]  941 	ld	-8 (ix), a
      00034F DD 36 F9 00      [19]  942 	ld	-7 (ix), #0x00
                           000353   943 	C$string.c$163$3_0$65	= .
                                    944 	.globl	C$string.c$163$3_0$65
                                    945 ;string.c:163: spanp = delim;
      000353 DD 7E 06         [19]  946 	ld	a, 6 (ix)
      000356 DD 77 FE         [19]  947 	ld	-2 (ix), a
      000359 DD 7E 07         [19]  948 	ld	a, 7 (ix)
      00035C DD 77 FF         [19]  949 	ld	-1 (ix), a
                           00035F   950 	C$string.c$164$3_0$65	= .
                                    951 	.globl	C$string.c$164$3_0$65
                                    952 ;string.c:164: do {
      00035F                        953 00108$:
                           00035F   954 	C$string.c$165$4_0$66	= .
                                    955 	.globl	C$string.c$165$4_0$66
                                    956 ;string.c:165: if ((sc = *spanp++) == c) {
      00035F DD 6E FE         [19]  957 	ld	l, -2 (ix)
      000362 DD 66 FF         [19]  958 	ld	h, -1 (ix)
      000365 4E               [ 7]  959 	ld	c, (hl)
      000366 DD 34 FE         [23]  960 	inc	-2 (ix)
      000369 20 03            [12]  961 	jr	NZ, 00149$
      00036B DD 34 FF         [23]  962 	inc	-1 (ix)
      00036E                        963 00149$:
      00036E 06 00            [ 7]  964 	ld	b, #0x00
      000370 DD 71 FA         [19]  965 	ld	-6 (ix), c
      000373 DD 70 FB         [19]  966 	ld	-5 (ix), b
      000376 DD 6E F8         [19]  967 	ld	l, -8 (ix)
      000379 DD 66 F9         [19]  968 	ld	h, -7 (ix)
      00037C BF               [ 4]  969 	cp	a, a
      00037D ED 42            [15]  970 	sbc	hl, bc
      00037F 20 2A            [12]  971 	jr	NZ, 00109$
                           000381   972 	C$string.c$166$2_0$63	= .
                                    973 	.globl	C$string.c$166$2_0$63
                                    974 ;string.c:166: if (c == 0)
      000381 DD 4E FC         [19]  975 	ld	c, -4 (ix)
      000384 DD 46 FD         [19]  976 	ld	b, -3 (ix)
      000387 DD 7E F9         [19]  977 	ld	a, -7 (ix)
      00038A DD B6 F8         [19]  978 	or	a, -8 (ix)
      00038D 20 05            [12]  979 	jr	NZ, 00104$
                           00038F   980 	C$string.c$167$5_0$67	= .
                                    981 	.globl	C$string.c$167$5_0$67
                                    982 ;string.c:167: s = NULL;
      00038F 01 00 00         [10]  983 	ld	bc, #0x0000
      000392 18 0C            [12]  984 	jr	00105$
      000394                        985 00104$:
                           000394   986 	C$string.c$169$5_0$67	= .
                                    987 	.globl	C$string.c$169$5_0$67
                                    988 ;string.c:169: s[-1] = 0;
      000394 DD 6E FC         [19]  989 	ld	l, -4 (ix)
      000397 DD 66 FD         [19]  990 	ld	h, -3 (ix)
      00039A 11 FF FF         [10]  991 	ld	de, #0xffff
      00039D 19               [11]  992 	add	hl, de
      00039E 36 00            [10]  993 	ld	(hl), #0x00
      0003A0                        994 00105$:
                           0003A0   995 	C$string.c$170$5_0$67	= .
                                    996 	.globl	C$string.c$170$5_0$67
                                    997 ;string.c:170: *stringp = s;
      0003A0 E1               [10]  998 	pop	hl
      0003A1 E5               [11]  999 	push	hl
      0003A2 71               [ 7] 1000 	ld	(hl), c
      0003A3 23               [ 6] 1001 	inc	hl
      0003A4 70               [ 7] 1002 	ld	(hl), b
                           0003A5  1003 	C$string.c$171$5_0$67	= .
                                   1004 	.globl	C$string.c$171$5_0$67
                                   1005 ;string.c:171: return (tok);
      0003A5 D1               [10] 1006 	pop	de
      0003A6 E1               [10] 1007 	pop	hl
      0003A7 E5               [11] 1008 	push	hl
      0003A8 D5               [11] 1009 	push	de
      0003A9 18 0A            [12] 1010 	jr	00114$
      0003AB                       1011 00109$:
                           0003AB  1012 	C$string.c$173$3_0$65	= .
                                   1013 	.globl	C$string.c$173$3_0$65
                                   1014 ;string.c:173: } while (sc != 0);
      0003AB DD 7E FB         [19] 1015 	ld	a, -5 (ix)
      0003AE DD B6 FA         [19] 1016 	or	a, -6 (ix)
      0003B1 20 AC            [12] 1017 	jr	NZ, 00108$
      0003B3 18 88            [12] 1018 	jr	00112$
      0003B5                       1019 00114$:
                           0003B5  1020 	C$string.c$175$2_0$63	= .
                                   1021 	.globl	C$string.c$175$2_0$63
                                   1022 ;string.c:175: }
      0003B5 DD F9            [10] 1023 	ld	sp, ix
      0003B7 DD E1            [14] 1024 	pop	ix
                           0003B9  1025 	C$string.c$175$2_0$63	= .
                                   1026 	.globl	C$string.c$175$2_0$63
                           0003B9  1027 	XG$strsep$0$0	= .
                                   1028 	.globl	XG$strsep$0$0
      0003B9 C9               [10] 1029 	ret
                           0003BA  1030 	G$strcspn$0$0	= .
                                   1031 	.globl	G$strcspn$0$0
                           0003BA  1032 	C$string.c$177$2_0$69	= .
                                   1033 	.globl	C$string.c$177$2_0$69
                                   1034 ;string.c:177: size_t strcspn(const char *s1, const char *s2) {
                                   1035 ;	---------------------------------
                                   1036 ; Function strcspn
                                   1037 ; ---------------------------------
      0003BA                       1038 _strcspn::
      0003BA DD E5            [15] 1039 	push	ix
      0003BC DD 21 00 00      [14] 1040 	ld	ix,#0
      0003C0 DD 39            [15] 1041 	add	ix,sp
      0003C2 F5               [11] 1042 	push	af
                           0003C3  1043 	C$string.c$178$2_0$69	= .
                                   1044 	.globl	C$string.c$178$2_0$69
                                   1045 ;string.c:178: size_t res = 0;
      0003C3 11 00 00         [10] 1046 	ld	de, #0x0000
                           0003C6  1047 	C$string.c$179$1_0$69	= .
                                   1048 	.globl	C$string.c$179$1_0$69
                                   1049 ;string.c:179: while (*s1 != '\0') {
      0003C6 DD 6E 04         [19] 1050 	ld	l, 4 (ix)
                                   1051 ;	spillPairReg hl
                                   1052 ;	spillPairReg hl
      0003C9 DD 66 05         [19] 1053 	ld	h, 5 (ix)
                                   1054 ;	spillPairReg hl
                                   1055 ;	spillPairReg hl
      0003CC AF               [ 4] 1056 	xor	a, a
      0003CD DD 77 FE         [19] 1057 	ld	-2 (ix), a
      0003D0 DD 77 FF         [19] 1058 	ld	-1 (ix), a
      0003D3                       1059 00104$:
      0003D3 7E               [ 7] 1060 	ld	a, (hl)
      0003D4 B7               [ 4] 1061 	or	a, a
      0003D5 28 2A            [12] 1062 	jr	Z, 00106$
                           0003D7  1063 	C$string.c$180$2_0$70	= .
                                   1064 	.globl	C$string.c$180$2_0$70
                                   1065 ;string.c:180: if (strchr(s2, *s1) == NULL) {
      0003D7 06 00            [ 7] 1066 	ld	b, #0x00
      0003D9 E5               [11] 1067 	push	hl
      0003DA D5               [11] 1068 	push	de
      0003DB 4F               [ 4] 1069 	ld	c, a
      0003DC C5               [11] 1070 	push	bc
      0003DD DD 4E 06         [19] 1071 	ld	c, 6 (ix)
      0003E0 DD 46 07         [19] 1072 	ld	b, 7 (ix)
      0003E3 C5               [11] 1073 	push	bc
      0003E4 CDrA3r02         [17] 1074 	call	_strchr
      0003E7 F1               [10] 1075 	pop	af
      0003E8 F1               [10] 1076 	pop	af
      0003E9 4D               [ 4] 1077 	ld	c, l
      0003EA 44               [ 4] 1078 	ld	b, h
      0003EB D1               [10] 1079 	pop	de
      0003EC E1               [10] 1080 	pop	hl
      0003ED 78               [ 4] 1081 	ld	a, b
      0003EE B1               [ 4] 1082 	or	a, c
      0003EF 20 0D            [12] 1083 	jr	NZ, 00102$
                           0003F1  1084 	C$string.c$181$3_0$71	= .
                                   1085 	.globl	C$string.c$181$3_0$71
                                   1086 ;string.c:181: ++s1;
      0003F1 23               [ 6] 1087 	inc	hl
                           0003F2  1088 	C$string.c$182$3_0$71	= .
                                   1089 	.globl	C$string.c$182$3_0$71
                                   1090 ;string.c:182: ++res;
      0003F2 DD 34 FE         [23] 1091 	inc	-2 (ix)
      0003F5 20 03            [12] 1092 	jr	NZ, 00124$
      0003F7 DD 34 FF         [23] 1093 	inc	-1 (ix)
      0003FA                       1094 00124$:
      0003FA D1               [10] 1095 	pop	de
      0003FB D5               [11] 1096 	push	de
      0003FC 18 D5            [12] 1097 	jr	00104$
      0003FE                       1098 00102$:
                           0003FE  1099 	C$string.c$184$3_0$72	= .
                                   1100 	.globl	C$string.c$184$3_0$72
                                   1101 ;string.c:184: return res;
      0003FE EB               [ 4] 1102 	ex	de, hl
      0003FF 18 01            [12] 1103 	jr	00107$
      000401                       1104 00106$:
                           000401  1105 	C$string.c$187$1_0$69	= .
                                   1106 	.globl	C$string.c$187$1_0$69
                                   1107 ;string.c:187: return res;
      000401 EB               [ 4] 1108 	ex	de, hl
      000402                       1109 00107$:
                           000402  1110 	C$string.c$188$1_0$69	= .
                                   1111 	.globl	C$string.c$188$1_0$69
                                   1112 ;string.c:188: }
      000402 DD F9            [10] 1113 	ld	sp, ix
      000404 DD E1            [14] 1114 	pop	ix
                           000406  1115 	C$string.c$188$1_0$69	= .
                                   1116 	.globl	C$string.c$188$1_0$69
                           000406  1117 	XG$strcspn$0$0	= .
                                   1118 	.globl	XG$strcspn$0$0
      000406 C9               [10] 1119 	ret
                           000407  1120 	G$strtok$0$0	= .
                                   1121 	.globl	G$strtok$0$0
                           000407  1122 	C$string.c$190$1_0$74	= .
                                   1123 	.globl	C$string.c$190$1_0$74
                                   1124 ;string.c:190: char *strtok(char *s, const char *delim) {
                                   1125 ;	---------------------------------
                                   1126 ; Function strtok
                                   1127 ; ---------------------------------
      000407                       1128 _strtok::
      000407 DD E5            [15] 1129 	push	ix
      000409 DD 21 00 00      [14] 1130 	ld	ix,#0
      00040D DD 39            [15] 1131 	add	ix,sp
      00040F 3B               [ 6] 1132 	dec	sp
                           000410  1133 	C$string.c$193$1_0$74	= .
                                   1134 	.globl	C$string.c$193$1_0$74
                                   1135 ;string.c:193: if (s == NULL) {
      000410 DD 7E 05         [19] 1136 	ld	a, 5 (ix)
      000413 DD B6 04         [19] 1137 	or	a, 4 (ix)
      000416 20 09            [12] 1138 	jr	NZ, 00114$
                           000418  1139 	C$string.c$194$2_0$75	= .
                                   1140 	.globl	C$string.c$194$2_0$75
                                   1141 ;string.c:194: s = last;
      000418 2Ar00r00         [16] 1142 	ld	hl, (_strtok_last_65536_74)
      00041B DD 75 04         [19] 1143 	ld	4 (ix), l
      00041E DD 74 05         [19] 1144 	ld	5 (ix), h
                           000421  1145 	C$string.c$197$1_1$74	= .
                                   1146 	.globl	C$string.c$197$1_1$74
                                   1147 ;string.c:197: do {
      000421                       1148 00114$:
      000421 DD 6E 04         [19] 1149 	ld	l, 4 (ix)
                                   1150 ;	spillPairReg hl
                                   1151 ;	spillPairReg hl
      000424 DD 66 05         [19] 1152 	ld	h, 5 (ix)
                                   1153 ;	spillPairReg hl
                                   1154 ;	spillPairReg hl
      000427                       1155 00105$:
                           000427  1156 	C$string.c$198$2_1$77	= .
                                   1157 	.globl	C$string.c$198$2_1$77
                                   1158 ;string.c:198: ch = *s++;
      000427 4E               [ 7] 1159 	ld	c, (hl)
      000428 23               [ 6] 1160 	inc	hl
      000429 06 00            [ 7] 1161 	ld	b, #0x00
      00042B 59               [ 4] 1162 	ld	e, c
                           00042C  1163 	C$string.c$199$2_1$77	= .
                                   1164 	.globl	C$string.c$199$2_1$77
                                   1165 ;string.c:199: if (ch == '\0') {
      00042C 78               [ 4] 1166 	ld	a,b
      00042D 57               [ 4] 1167 	ld	d,a
      00042E B1               [ 4] 1168 	or	a, c
      00042F 20 05            [12] 1169 	jr	NZ, 00106$
                           000431  1170 	C$string.c$200$3_1$78	= .
                                   1171 	.globl	C$string.c$200$3_1$78
                                   1172 ;string.c:200: return NULL;
      000431 21 00 00         [10] 1173 	ld	hl, #0x0000
      000434 18 47            [12] 1174 	jr	00110$
      000436                       1175 00106$:
                           000436  1176 	C$string.c$202$1_1$76	= .
                                   1177 	.globl	C$string.c$202$1_1$76
                                   1178 ;string.c:202: } while (strchr(delim, ch));
      000436 E5               [11] 1179 	push	hl
      000437 D5               [11] 1180 	push	de
      000438 DD 5E 06         [19] 1181 	ld	e, 6 (ix)
      00043B DD 56 07         [19] 1182 	ld	d, 7 (ix)
      00043E D5               [11] 1183 	push	de
      00043F CDrA3r02         [17] 1184 	call	_strchr
      000442 F1               [10] 1185 	pop	af
      000443 F1               [10] 1186 	pop	af
      000444 EB               [ 4] 1187 	ex	de, hl
      000445 E1               [10] 1188 	pop	hl
      000446 7A               [ 4] 1189 	ld	a, d
      000447 B3               [ 4] 1190 	or	a, e
      000448 20 DD            [12] 1191 	jr	NZ, 00105$
                           00044A  1192 	C$string.c$203$1_1$76	= .
                                   1193 	.globl	C$string.c$203$1_1$76
                                   1194 ;string.c:203: --s;
      00044A 4D               [ 4] 1195 	ld	c, l
      00044B 44               [ 4] 1196 	ld	b, h
      00044C 0B               [ 6] 1197 	dec	bc
                           00044D  1198 	C$string.c$204$1_1$76	= .
                                   1199 	.globl	C$string.c$204$1_1$76
                                   1200 ;string.c:204: last = s + strcspn(s, delim);
      00044D C5               [11] 1201 	push	bc
      00044E DD 6E 06         [19] 1202 	ld	l, 6 (ix)
                                   1203 ;	spillPairReg hl
                                   1204 ;	spillPairReg hl
      000451 DD 66 07         [19] 1205 	ld	h, 7 (ix)
                                   1206 ;	spillPairReg hl
                                   1207 ;	spillPairReg hl
      000454 E5               [11] 1208 	push	hl
      000455 C5               [11] 1209 	push	bc
      000456 CDrBAr03         [17] 1210 	call	_strcspn
      000459 F1               [10] 1211 	pop	af
      00045A F1               [10] 1212 	pop	af
      00045B EB               [ 4] 1213 	ex	de, hl
      00045C C1               [10] 1214 	pop	bc
      00045D 7B               [ 4] 1215 	ld	a, e
      00045E 21r00r00         [10] 1216 	ld	hl, #_strtok_last_65536_74
      000461 81               [ 4] 1217 	add	a, c
      000462 77               [ 7] 1218 	ld	(hl), a
      000463 23               [ 6] 1219 	inc	hl
      000464 7A               [ 4] 1220 	ld	a, d
      000465 88               [ 4] 1221 	adc	a, b
      000466 77               [ 7] 1222 	ld	(hl), a
                           000467  1223 	C$string.c$194$1_1$74	= .
                                   1224 	.globl	C$string.c$194$1_1$74
                                   1225 ;string.c:194: s = last;
      000467 ED 5Br00r00      [20] 1226 	ld	de, (_strtok_last_65536_74)
                           00046B  1227 	C$string.c$205$1_1$76	= .
                                   1228 	.globl	C$string.c$205$1_1$76
                                   1229 ;string.c:205: if (*last != '\0') {
      00046B 1A               [ 7] 1230 	ld	a, (de)
      00046C DD 77 FF         [19] 1231 	ld	-1 (ix), a
      00046F B7               [ 4] 1232 	or	a, a
      000470 28 09            [12] 1233 	jr	Z, 00109$
                           000472  1234 	C$string.c$206$2_1$79	= .
                                   1235 	.globl	C$string.c$206$2_1$79
                                   1236 ;string.c:206: *last++ = '\0';
      000472 AF               [ 4] 1237 	xor	a, a
      000473 12               [ 7] 1238 	ld	(de), a
      000474 2Ar00r00         [16] 1239 	ld	hl, (_strtok_last_65536_74)
      000477 23               [ 6] 1240 	inc	hl
      000478 22r00r00         [16] 1241 	ld	(_strtok_last_65536_74), hl
      00047B                       1242 00109$:
                           00047B  1243 	C$string.c$208$1_1$76	= .
                                   1244 	.globl	C$string.c$208$1_1$76
                                   1245 ;string.c:208: return s;
      00047B 69               [ 4] 1246 	ld	l, c
                                   1247 ;	spillPairReg hl
                                   1248 ;	spillPairReg hl
      00047C 60               [ 4] 1249 	ld	h, b
                                   1250 ;	spillPairReg hl
                                   1251 ;	spillPairReg hl
      00047D                       1252 00110$:
                           00047D  1253 	C$string.c$209$1_1$74	= .
                                   1254 	.globl	C$string.c$209$1_1$74
                                   1255 ;string.c:209: }
      00047D 33               [ 6] 1256 	inc	sp
      00047E DD E1            [14] 1257 	pop	ix
                           000480  1258 	C$string.c$209$1_1$74	= .
                                   1259 	.globl	C$string.c$209$1_1$74
                           000480  1260 	XG$strtok$0$0	= .
                                   1261 	.globl	XG$strtok$0$0
      000480 C9               [10] 1262 	ret
                           000481  1263 	G$strerror$0$0	= .
                                   1264 	.globl	G$strerror$0$0
                           000481  1265 	C$string.c$211$1_1$81	= .
                                   1266 	.globl	C$string.c$211$1_1$81
                                   1267 ;string.c:211: char *strerror(int en)
                                   1268 ;	---------------------------------
                                   1269 ; Function strerror
                                   1270 ; ---------------------------------
      000481                       1271 _strerror::
      000481 DD E5            [15] 1272 	push	ix
      000483 DD 21 00 00      [14] 1273 	ld	ix,#0
      000487 DD 39            [15] 1274 	add	ix,sp
                           000489  1275 	C$string.c$213$1_0$81	= .
                                   1276 	.globl	C$string.c$213$1_0$81
                                   1277 ;string.c:213: switch(en) {
      000489 DD 7E 04         [19] 1278 	ld	a, 4 (ix)
      00048C B7               [ 4] 1279 	or	a, a
      00048D DD B6 05         [19] 1280 	or	a, 5 (ix)
      000490 28 5C            [12] 1281 	jr	Z, 00101$
      000492 DD 7E 04         [19] 1282 	ld	a, 4 (ix)
      000495 D6 02            [ 7] 1283 	sub	a, #0x02
      000497 DD B6 05         [19] 1284 	or	a, 5 (ix)
      00049A 28 57            [12] 1285 	jr	Z, 00102$
      00049C DD 7E 04         [19] 1286 	ld	a, 4 (ix)
      00049F D6 05            [ 7] 1287 	sub	a, #0x05
      0004A1 DD B6 05         [19] 1288 	or	a, 5 (ix)
      0004A4 28 52            [12] 1289 	jr	Z, 00103$
      0004A6 DD 7E 04         [19] 1290 	ld	a, 4 (ix)
      0004A9 D6 07            [ 7] 1291 	sub	a, #0x07
      0004AB DD B6 05         [19] 1292 	or	a, 5 (ix)
      0004AE 28 4D            [12] 1293 	jr	Z, 00104$
      0004B0 DD 7E 04         [19] 1294 	ld	a, 4 (ix)
      0004B3 D6 09            [ 7] 1295 	sub	a, #0x09
      0004B5 DD B6 05         [19] 1296 	or	a, 5 (ix)
      0004B8 28 48            [12] 1297 	jr	Z, 00105$
      0004BA DD 7E 04         [19] 1298 	ld	a, 4 (ix)
      0004BD D6 0B            [ 7] 1299 	sub	a, #0x0b
      0004BF DD B6 05         [19] 1300 	or	a, 5 (ix)
      0004C2 28 57            [12] 1301 	jr	Z, 00110$
      0004C4 DD 7E 04         [19] 1302 	ld	a, 4 (ix)
      0004C7 D6 16            [ 7] 1303 	sub	a, #0x16
      0004C9 DD B6 05         [19] 1304 	or	a, 5 (ix)
      0004CC 28 39            [12] 1305 	jr	Z, 00106$
      0004CE DD 7E 04         [19] 1306 	ld	a, 4 (ix)
      0004D1 D6 17            [ 7] 1307 	sub	a, #0x17
      0004D3 DD B6 05         [19] 1308 	or	a, 5 (ix)
      0004D6 28 34            [12] 1309 	jr	Z, 00107$
      0004D8 DD 7E 04         [19] 1310 	ld	a, 4 (ix)
      0004DB D6 19            [ 7] 1311 	sub	a, #0x19
      0004DD DD B6 05         [19] 1312 	or	a, 5 (ix)
      0004E0 28 2F            [12] 1313 	jr	Z, 00108$
      0004E2 DD 7E 04         [19] 1314 	ld	a, 4 (ix)
      0004E5 D6 20            [ 7] 1315 	sub	a, #0x20
      0004E7 DD B6 05         [19] 1316 	or	a, 5 (ix)
      0004EA 28 2A            [12] 1317 	jr	Z, 00109$
      0004EC 18 32            [12] 1318 	jr	00111$
                           0004EE  1319 	C$string.c$214$2_0$82	= .
                                   1320 	.globl	C$string.c$214$2_0$82
                                   1321 ;string.c:214: case 0:
      0004EE                       1322 00101$:
                           0004EE  1323 	C$string.c$215$2_0$82	= .
                                   1324 	.globl	C$string.c$215$2_0$82
                                   1325 ;string.c:215: return (const char *) "Success";
      0004EE 21r26r05         [10] 1326 	ld	hl, #___str_0
      0004F1 18 30            [12] 1327 	jr	00112$
                           0004F3  1328 	C$string.c$217$2_0$82	= .
                                   1329 	.globl	C$string.c$217$2_0$82
                                   1330 ;string.c:217: case ENOENT:
      0004F3                       1331 00102$:
                           0004F3  1332 	C$string.c$218$2_0$82	= .
                                   1333 	.globl	C$string.c$218$2_0$82
                                   1334 ;string.c:218: return (const char *) "No such file or directory";
      0004F3 21r2Er05         [10] 1335 	ld	hl, #___str_1
      0004F6 18 2B            [12] 1336 	jr	00112$
                           0004F8  1337 	C$string.c$220$2_0$82	= .
                                   1338 	.globl	C$string.c$220$2_0$82
                                   1339 ;string.c:220: case EIO:
      0004F8                       1340 00103$:
                           0004F8  1341 	C$string.c$221$2_0$82	= .
                                   1342 	.globl	C$string.c$221$2_0$82
                                   1343 ;string.c:221: return (const char *) "I/O error";
      0004F8 21r48r05         [10] 1344 	ld	hl, #___str_2
      0004FB 18 26            [12] 1345 	jr	00112$
                           0004FD  1346 	C$string.c$223$2_0$82	= .
                                   1347 	.globl	C$string.c$223$2_0$82
                                   1348 ;string.c:223: case E2BIG:
      0004FD                       1349 00104$:
                           0004FD  1350 	C$string.c$224$2_0$82	= .
                                   1351 	.globl	C$string.c$224$2_0$82
                                   1352 ;string.c:224: return (const char *) "Argument list too long";
      0004FD 21r52r05         [10] 1353 	ld	hl, #___str_3
      000500 18 21            [12] 1354 	jr	00112$
                           000502  1355 	C$string.c$226$2_0$82	= .
                                   1356 	.globl	C$string.c$226$2_0$82
                                   1357 ;string.c:226: case EBADF:
      000502                       1358 00105$:
                           000502  1359 	C$string.c$227$2_0$82	= .
                                   1360 	.globl	C$string.c$227$2_0$82
                                   1361 ;string.c:227: return (const char *) "Bad file descriptor";
      000502 21r69r05         [10] 1362 	ld	hl, #___str_4
      000505 18 1C            [12] 1363 	jr	00112$
                           000507  1364 	C$string.c$229$2_0$82	= .
                                   1365 	.globl	C$string.c$229$2_0$82
                                   1366 ;string.c:229: case EINVAL:
      000507                       1367 00106$:
                           000507  1368 	C$string.c$230$2_0$82	= .
                                   1369 	.globl	C$string.c$230$2_0$82
                                   1370 ;string.c:230: return (const char *) "Illegal address";
      000507 21r7Dr05         [10] 1371 	ld	hl, #___str_5
      00050A 18 17            [12] 1372 	jr	00112$
                           00050C  1373 	C$string.c$232$2_0$82	= .
                                   1374 	.globl	C$string.c$232$2_0$82
                                   1375 ;string.c:232: case ENFILE:
      00050C                       1376 00107$:
                           00050C  1377 	C$string.c$233$2_0$82	= .
                                   1378 	.globl	C$string.c$233$2_0$82
                                   1379 ;string.c:233: return (const char *) "File table overflow";
      00050C 21r8Dr05         [10] 1380 	ld	hl, #___str_6
      00050F 18 12            [12] 1381 	jr	00112$
                           000511  1382 	C$string.c$235$2_0$82	= .
                                   1383 	.globl	C$string.c$235$2_0$82
                                   1384 ;string.c:235: case ENOTTY:
      000511                       1385 00108$:
                           000511  1386 	C$string.c$236$2_0$82	= .
                                   1387 	.globl	C$string.c$236$2_0$82
                                   1388 ;string.c:236: return (const char *) "Not a typewriter";
      000511 21rA1r05         [10] 1389 	ld	hl, #___str_7
      000514 18 0D            [12] 1390 	jr	00112$
                           000516  1391 	C$string.c$238$2_0$82	= .
                                   1392 	.globl	C$string.c$238$2_0$82
                                   1393 ;string.c:238: case EPIPE:
      000516                       1394 00109$:
                           000516  1395 	C$string.c$239$2_0$82	= .
                                   1396 	.globl	C$string.c$239$2_0$82
                                   1397 ;string.c:239: return (const char *) "Transport endpoint not connected";
      000516 21rB2r05         [10] 1398 	ld	hl, #___str_8
      000519 18 08            [12] 1399 	jr	00112$
                           00051B  1400 	C$string.c$241$2_0$82	= .
                                   1401 	.globl	C$string.c$241$2_0$82
                                   1402 ;string.c:241: case EAGAIN:
      00051B                       1403 00110$:
                           00051B  1404 	C$string.c$242$2_0$82	= .
                                   1405 	.globl	C$string.c$242$2_0$82
                                   1406 ;string.c:242: return (const char *) "Try again";
      00051B 21rD3r05         [10] 1407 	ld	hl, #___str_9
      00051E 18 03            [12] 1408 	jr	00112$
                           000520  1409 	C$string.c$244$1_0$81	= .
                                   1410 	.globl	C$string.c$244$1_0$81
                                   1411 ;string.c:244: }
      000520                       1412 00111$:
                           000520  1413 	C$string.c$246$1_0$81	= .
                                   1414 	.globl	C$string.c$246$1_0$81
                                   1415 ;string.c:246: return "Unknown error!";
      000520 21rDDr05         [10] 1416 	ld	hl, #___str_10
      000523                       1417 00112$:
                           000523  1418 	C$string.c$247$1_0$81	= .
                                   1419 	.globl	C$string.c$247$1_0$81
                                   1420 ;string.c:247: }
      000523 DD E1            [14] 1421 	pop	ix
                           000525  1422 	C$string.c$247$1_0$81	= .
                                   1423 	.globl	C$string.c$247$1_0$81
                           000525  1424 	XG$strerror$0$0	= .
                                   1425 	.globl	XG$strerror$0$0
      000525 C9               [10] 1426 	ret
                           000526  1427 Fstring$__str_0$0_0$0 == .
      000526                       1428 ___str_0:
      000526 53 75 63 63 65 73 73  1429 	.ascii "Success"
      00052D 00                    1430 	.db 0x00
                           00052E  1431 Fstring$__str_1$0_0$0 == .
      00052E                       1432 ___str_1:
      00052E 4E 6F 20 73 75 63 68  1433 	.ascii "No such file or directory"
             20 66 69 6C 65 20 6F
             72 20 64 69 72 65 63
             74 6F 72 79
      000547 00                    1434 	.db 0x00
                           000548  1435 Fstring$__str_2$0_0$0 == .
      000548                       1436 ___str_2:
      000548 49 2F 4F 20 65 72 72  1437 	.ascii "I/O error"
             6F 72
      000551 00                    1438 	.db 0x00
                           000552  1439 Fstring$__str_3$0_0$0 == .
      000552                       1440 ___str_3:
      000552 41 72 67 75 6D 65 6E  1441 	.ascii "Argument list too long"
             74 20 6C 69 73 74 20
             74 6F 6F 20 6C 6F 6E
             67
      000568 00                    1442 	.db 0x00
                           000569  1443 Fstring$__str_4$0_0$0 == .
      000569                       1444 ___str_4:
      000569 42 61 64 20 66 69 6C  1445 	.ascii "Bad file descriptor"
             65 20 64 65 73 63 72
             69 70 74 6F 72
      00057C 00                    1446 	.db 0x00
                           00057D  1447 Fstring$__str_5$0_0$0 == .
      00057D                       1448 ___str_5:
      00057D 49 6C 6C 65 67 61 6C  1449 	.ascii "Illegal address"
             20 61 64 64 72 65 73
             73
      00058C 00                    1450 	.db 0x00
                           00058D  1451 Fstring$__str_6$0_0$0 == .
      00058D                       1452 ___str_6:
      00058D 46 69 6C 65 20 74 61  1453 	.ascii "File table overflow"
             62 6C 65 20 6F 76 65
             72 66 6C 6F 77
      0005A0 00                    1454 	.db 0x00
                           0005A1  1455 Fstring$__str_7$0_0$0 == .
      0005A1                       1456 ___str_7:
      0005A1 4E 6F 74 20 61 20 74  1457 	.ascii "Not a typewriter"
             79 70 65 77 72 69 74
             65 72
      0005B1 00                    1458 	.db 0x00
                           0005B2  1459 Fstring$__str_8$0_0$0 == .
      0005B2                       1460 ___str_8:
      0005B2 54 72 61 6E 73 70 6F  1461 	.ascii "Transport endpoint not connected"
             72 74 20 65 6E 64 70
             6F 69 6E 74 20 6E 6F
             74 20 63 6F 6E 6E 65
             63 74 65 64
      0005D2 00                    1462 	.db 0x00
                           0005D3  1463 Fstring$__str_9$0_0$0 == .
      0005D3                       1464 ___str_9:
      0005D3 54 72 79 20 61 67 61  1465 	.ascii "Try again"
             69 6E
      0005DC 00                    1466 	.db 0x00
                           0005DD  1467 Fstring$__str_10$0_0$0 == .
      0005DD                       1468 ___str_10:
      0005DD 55 6E 6B 6E 6F 77 6E  1469 	.ascii "Unknown error!"
             20 65 72 72 6F 72 21
      0005EB 00                    1470 	.db 0x00
                                   1471 	.area _CODE
                                   1472 	.area _INITIALIZER
                                   1473 	.area _CABS (ABS)
